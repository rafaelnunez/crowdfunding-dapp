import{C as w,_ as o,w as d,x as y,y as n,z as r,g,S as f,cy as v,cz as C}from"./index.7594c645.js";class h extends f{constructor(t){super(),this.signer=t,v.defineReadOnly(this,"provider",t.provider)}async getAddress(){return await this.signer.getAddress()}async signMessage(t){return await this.signer.signMessage(t)}async signTransaction(t){return await this.signer.signTransaction(t)}connect(t){return new h(this.signer.connect(t))}_signTypedData(t,s,e){return this.signer._signTypedData(t,s,e)}async sendTransaction(t){if(!this.provider)throw new Error("Provider not found");const e={...await C(this.provider),...t};return await this.signer.sendTransaction(e)}}var i=new WeakMap,a=new WeakMap;class _ extends w{constructor(t){super(),o(this,"id","local_wallet"),o(this,"name","Local Wallet"),d(this,i,{writable:!0,value:void 0}),d(this,a,{writable:!0,value:void 0}),o(this,"shimDisconnectKey","localWallet.shimDisconnect"),o(this,"onChainChanged",s=>{const e=y(s),p=!this.options.chains.find(u=>u.chainId===e);this.emit("change",{chain:{id:e,unsupported:p}})}),this.options=t}async connect(t){return t.chainId&&this.switchChain(t.chainId),await(await this.getSigner()).getAddress()}async disconnect(){n(this,i,void 0),n(this,a,void 0)}async getAddress(){const t=await this.getSigner();if(!t)throw new Error("No signer found");return await t.getAddress()}async isConnected(){try{return!!await this.getAddress()}catch{return!1}}async getProvider(){return r(this,i)||n(this,i,g(this.options.chain,{clientId:this.options.clientId,secretKey:this.options.secretKey})),r(this,i)}async getSigner(){if(!r(this,a)){const t=await this.getProvider();n(this,a,l(this.options.ethersWallet,t))}return r(this,a)}async switchChain(t){const s=this.options.chains.find(e=>e.chainId===t);if(!s)throw new Error(`Chain not found for chainId ${t}, please add it to the chains property when creating this wallet`);n(this,i,g(s,{clientId:this.options.clientId,secretKey:this.options.secretKey})),n(this,a,l(this.options.ethersWallet,r(this,i))),this.onChainChanged(t)}async setupListeners(){}updateChains(t){this.options.chains=t}}function l(c,t){let s=c;return t&&(s=c.connect(t)),new h(s)}export{_ as LocalWalletConnector};
